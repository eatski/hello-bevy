# 型システムの構築

## Context
hello-bevy プロジェクトでは、ゲームロジックをトークンベースの宣言的な記述で表現できるようにすることでユーザーに自由な戦闘の戦略を決定することを目指したい。
現在の `crates/token-input/src/converter.rs` の実装は、場当たり的な変換ロジックの羅列となっており、今後の拡張に対してスケールしない。より本格的な型システムとコンパイラアーキテクチャが必要である。

### 目指す姿

- 今後、トークンの種類が増える際のnodeへの変換ロジックが
  - 最小になっていること
  - 修正漏れが発生しずらいこと
- コアの言語システムが個々のトークンに依存しない形になっていること 

### 考えられる拡張

- より複雑な型を持つトークンの追加
- 様々な種類のトークンの追加
- 基本型の追加

## Decision
言語コアシステムとして、以下の3層アーキテクチャを採用する：

### 1. フロントエンド層（Frontend Layer）
- **役割**: 各種入力形式（UI、JSON）を受け付ける
- **特徴**:
  - 入力形式ごとに専用のデータ構造を定義
  - 演算子の概念は存在せず、すべてトークン（関数）として表現
  - 例: `=` 演算子ではなく `Eq(a, b)` トークン
- **実装例**:
  - `rules/enemy_rules.json`

### 2. コア層（Core Layer）
- **役割**: 型定義と型解決のルールを管理
- **機能**:
  - **静的型検査**: 基本的な型チェック機能を提供
  - **型推論**: フロントエンドからの型指定なしに型を自動推論
  - **ジェネリクス**: 型パラメータによる汎用的な型定義
  - **抽象型**: `Numeric` のような共通インターフェースの定義
- **設計方針**:
  - 具体的な型に依存せず、構造的な型解決ルールのみを定義
  - エラーフィードバックをユーザーに適切に伝達

### 3. 実行層（Execution Layer）
- **役割**: コンパイル結果を実行可能な形式に変換
- **出力**: 木構造の `Node` グラフ
- **特徴**:
  - 各 `Node` が実行時ロジックを直接保持
  - `action-system` クレートで実装

## アーキテクチャ詳細

### 型システム設計

#### 基本型
- プリミティブ型: `number`, `bool`
- ゲーム固有型: `Character`, `Team`, `CharacterHP`
- コレクション型: `Vec<T>`

#### 抽象型
```
trait Numeric {
    fn value(&self) -> i32;
}

// CharacterHP と i32 の両方が Numeric を実装
// これにより GreaterThan(CharacterHP, i32) のような異なる型の比較が可能
```

#### 型推論
RondomPickやMaxなどの関数は様々な型を要素として持つ配列を受け取り、その型の値を返却する。
引数の型から返り値の型を決定する機能が必要

#### 擬似関数の実現
フロントエンドに関数概念は存在しないが、特定のトークンで擬似的に実現

例: 全てのキャラクターからHero側のキャラクターを取得する
```json
{
  "type": "FilterList",
  "array": {
    "type": "AllCharacters"
  },
  "condition": {
    "type": "Eq",
    "left": {
      "type": "CharacterTeam",
      "character": {
        "type": "Element"
      }
    },
    "right": {
      "type": "Hero"
    }
  }
}
```

### コンパイルパイプライン
```
入力（JSON/UI）
    ↓
構造化トークン（StructuredTokenInput）
    ↓
型検査・型推論
    ↓
中間表現（型付きAST）
    ↓
最適化
    ↓
実行可能Node
```
