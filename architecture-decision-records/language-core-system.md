# 本格的な型つきプログラミング言語としてリアーキテクチャ

crates/token-input/src/structured_to_node.rsは行き当たりばっかりの変換ロジックを書き連ねておりスケールしない
本格的な型システムを有するコンパイラを開発する必要がある

## 言語アーキテクチャ

### フロントエンド
参考: crates/token-input
プログラムはトークンを組み合わせ、構造体を作る形で定義していく
入力としてはすでに構造化されたものを想定して文字列からのparseをする必要がない

また、演算子などの概念は存在せずすべてtokenがそれを担う
例: `=` は存在せず `Eq(a,b)` 関数がある


#### 入力の例
- rules/enemy_rules.json
- crates/token-input/src/structured_token.rs

### アウトプット
コンパイルで木構造のNodeをアウトプットし、そのNodeはそのまま実行できる
Nodeの実体が実行時のロジックを持つ

[最終アウトプット](crates/action-system)

### コア
コアは型定義のルールのみを定義する
具体的な型は意識せず、構造体のinputについてどのように型を解決していくかのみを決める

#### 型定義
基本的な静的型検査機能を持ち、検査のFBをユーザーに伝えられる

##### 関数
フロントエンドには関数は存在しないが、Mappingなどの
トークンの一部引数内では、引数トークンを使って、関数の引数を取得することで擬似的に関数を実装できる

Mapping {
  array: Somethings
  transform: MappingLogic
}

##### ジェネリクス
フロントエンドからは型を明示的に指定できず、すべて型推論で型を決定する


##### 抽象型
例: Numeric

Numericは数値やキャラクターのHPなどを包括した抽象概念
大小比較関数などはNumericな型であれば、別の型同士でも比較可能



